import{u as n}from"./vue.-sixQ7xP-deYJhieZ.js";import{c as a,o as i,a as t}from"./index-NEwBzf1q.js";const s={class:"markdown-body"},u="SLGL",m="2022-02-10T00:00:00.000Z",_="Typed convenience functions for working directly with shaders and WebGL.",f=!0,L=1.4,g=["OPEN_SOURCE","SOFTWARE","USER_INTERFACE"],E=["WEBGL_ABILITY","SHADER_PROGRAMMING_ABILITY"],w="https://github.com/ShiftLimits/slgl",G=[],I={__name:"index",setup(r,{expose:o}){return o({frontmatter:{name:"SLGL",start_date:"2022-02-10T00:00:00.000Z",short_description:"Typed convenience functions for working directly with shaders and WebGL.",highlight:!0,carousel_aspect:1.4,categories:["OPEN_SOURCE","SOFTWARE","USER_INTERFACE"],abilities:["WEBGL_ABILITY","SHADER_PROGRAMMING_ABILITY"],repo:"https://github.com/ShiftLimits/slgl",meta:[]}}),n({meta:[]}),(d,e)=>(i(),a("div",s,e[0]||(e[0]=[t("h1",null,"SLGL",-1),t("p",null,"SLGL is a set of typed utilities for working with WebGL. I put this collection together after working on a number of simulations written directly with WebGL. I approached each utility in a functional way and worked to simplify the developer experience when creating shader-based projects.",-1),t("p",null,"The patterns found in SLGL allow for GPU programs to be constructed as plain old functions to be called when you need them which opens up a lot of modularity. For instance, for the Hyunâ€™s Dojo Beta Landing project I encapsulated the Jump Flood Algorithm into a program that can be applied to any texture.",-1)])))}};export{E as abilities,L as carousel_aspect,g as categories,I as default,f as highlight,G as meta,u as name,w as repo,_ as short_description,m as start_date};
